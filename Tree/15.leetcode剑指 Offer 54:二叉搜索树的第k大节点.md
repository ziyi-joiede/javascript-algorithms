# 剑指 Offer 54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点。

**示例 1:**
```js
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**示例 2:**
```js
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

来源：力扣（LeetCode）
链接：[https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof)
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 解-递归法
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargest = function(root, k) {
	let res = [];
	let dfs = root => {
		if(!root) {
			return;
		}
		dfs(root.right);
		res.push(root.val);
		dfs(root.left);
	}
	dfs(root);
	return res[k - 1];
}
```

### 解-迭代法
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargest = function(root, k) {
	if(!root){
		return null;
	}
	let res = [];
	let stack = [];
	let p = root;
	while(p || stack.length){
		while(p){
			stack.push(p);
			p = p.right;
		}
		p = stack.pop();
		res.push(p.val);
		if(res.length === k){
			return res.pop();
		}
		p = p.left;
	}
	return null;
}
```