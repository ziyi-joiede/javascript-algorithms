# 872. 叶子相似的树

请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。

![avatar](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png)

举个例子，如上图所示，给定一棵叶值序列为 `(6, 7, 4, 9, 8)` 的树。

如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 的。

如果给定的两个头结点分别为 `root1` 和 `root2` 的树是叶相似的，则返回 `true`；否则返回 `false` 。

**示例 1：**

![avatar](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg)

```js
输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出：true
```

**示例 2：**

```js
输入：root1 = [1], root2 = [1]
输出：true
```

**示例 3：**
```js
输入：root1 = [1], root2 = [2]
输出：false
```

**示例 4：**
```js
输入：root1 = [1,2], root2 = [2,2]
输出：true
```

**示例 5：**

![avatar](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg)

```js
输入：root1 = [1,2,3], root2 = [1,3,2]
输出：false
```

来源：力扣（LeetCode）
链接：[https://leetcode-cn.com/problems/leaf-similar-trees](https://leetcode-cn.com/problems/leaf-similar-trees)
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 解-递归
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
	let dfs = (root, res = []) => {
		if(root){
			if(!root.left && !root.right){
				res.push(root.val);
			}
			if(root.left || root.right){
				root.left && dfs(root.left, res);
				root.right && dfs(root.right, res);
			}
		}
	}
	let res1 = dfs(root1);
	let res2 = dfs(root2);
	return res1.toString() === res2.toString();
}
```

### 解-迭代
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
	let dfs = (root, res = []) => {
		let stack = [root];
		while(stack.length){
			let top = stack.pop();
			if(!top.left && !top.right){
				res.push(top.val);
			}
			top.right && stack.push(top.right);
			top.left && stack.push(top.left);
		}
	}
	let res1 = dfs(root1);
	let res2 = dfs(root2);
	return res1.toString() === res2.toString();
}
```